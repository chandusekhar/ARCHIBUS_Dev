package com.archibus.app.solution.common.report.crystal.adaptor.freesdk;

import java.io.InputStream;
import java.sql.*;
import java.util.*;

import com.archibus.config.ConfigJdbc;
import com.archibus.context.*;
import com.archibus.datasource.*;
import com.archibus.security.UserAccount;
import com.archibus.utility.*;
import com.crystaldecisions.sdk.occa.report.application.ReportClientDocument;
import com.crystaldecisions.sdk.occa.report.data.*;
import com.crystaldecisions.sdk.occa.report.exportoptions.ReportExportFormat;
import com.crystaldecisions.sdk.occa.report.lib.*;

/**
 * Utilities for CrystalReportsAdaptor.
 * <p>
 * Integrates Crystal Report SDK with WebCentral.
 *
 * @author Valery Tydykov
 * @since 21.3
 */
public final class CrystalReportsAdaptorUtilities {
    /**
     * Private default constructor: utility class is non-instantiable.
     */
    private CrystalReportsAdaptorUtilities() {
    }

    /**
     * Prepares crystal report. Replaces database connection parameters in report with connection
     * parameters values from the "data" connection in the current context; Gets SQL generated by
     * Crystal Reports SDK; Applies VPA restrictions from the current user account.
     *
     * @param reportFileName name of .rpt file with report definition.
     * @param userAccount current user account.
     * @param applyVpa if true, applies VPA restrictions from the current user account.
     * @param reportClientDocument Crystal Reports SDK document to be processed.
     * @param clientRestriction restriction passed from client-side
     *
     * @return SQL that has both SQL generated by Crystal Reports SDK and VPA restrictions.
     * @throws ReportSDKException if Crystal Reports SDK throws an exception.
     */
    static String prepareReport(final String reportFileName,
            final UserAccount.Immutable userAccount, final boolean applyVpa,
            final ReportClientDocument reportClientDocument, final String clientRestriction)
            throws ReportSDKException {
        // Commented out based on ICAD codes (03/2015)
        // replaceConnectionParameters(userAccount, reportClientDocument);

        // Always logon to the DB before extracting the query
        // based on ICAD codes (03/2015)
        logonDataSource(reportClientDocument, userAccount);

        final String originalSql = getSqlStatementFromReport(reportFileName, reportClientDocument);

        return applyVpa(applyVpa, reportClientDocument, originalSql, clientRestriction);
    }

    /**
     * Generates report as stream, using ResultSet produced from sqlWithVpa as DataSource of the
     * report.
     *
     * @param reportClientDocument Crystal Reports SDK document to be processed.
     * @param sqlWithVpa SQL that has both SQL generated by Crystal Reports SDK and VPA
     *            restrictions.
     * @return stream with generated PDF report.
     * @throws SQLException if JDBC throws an exception.
     * @throws ReportSDKException if Crystal Reports SDK throws an exception.
     */
    static InputStream generateReport(final ReportClientDocument reportClientDocument,
            final String sqlWithVpa)
            // CHECKSTYLE:OFF Justification: Suppress "Throws count is 2" warning: I see no way to separate
            // code that uses JDBC from code that uses Crystal Reports SDK.
                    throws SQLException, ReportSDKException {
        // CHECKSTYLE:ON

        // Get current database connection from the context
        final java.sql.Connection connection = ContextStore.get().getDbConnection().getConnection();
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            // Retrieve data for report
            statement =
                    connection.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,
                        ResultSet.CONCUR_READ_ONLY);

            resultSet = statement.executeQuery(sqlWithVpa);

            // Replace DataSource in report
            reportClientDocument.getDatabaseController().setDataSource(resultSet, null, null);

            // Generate report
            final InputStream inputStream =
                    reportClientDocument.getPrintOutputController().export(ReportExportFormat.PDF);

            return inputStream;
        } finally {
            if (resultSet != null) {
                resultSet.close();
            }

            if (statement != null) {
                statement.close();
            }

            // do NOT call connection.close() - it would return connection to the pool
            // and invalidate it in the current context, so all subsequent database
            // operations in this user transaction will fail.
        }
    }

    /**
     * Applies VPA restrictions from userAccount, if applyVpa is true.
     * <p>
     * Gets list of table names from the reportClientDocument. Applies VPA restrictions to
     * originalSqlStatement.
     *
     * @param applyVpa if true, applies VPA restrictions from the current user account.
     * @param reportClientDocument Crystal Reports SDK document to be processed.
     * @param originalSqlStatement SQL generated by Crystal Reports SDK.
     * @param clientRestriction restriction passed from client-side
     *
     * @return SQL that has both SQL generated by Crystal Reports SDK and VPA restrictions.
     * @throws ReportSDKException if Crystal Reports SDK throws an exception.
     */
    static String applyVpa(final boolean applyVpa, final ReportClientDocument reportClientDocument,
            final String originalSqlStatement, final String clientRestriction)
            throws ReportSDKException {
        String sqlWithRestrictions = originalSqlStatement;
        
        // Get list of table names from the report
        final Tables tables =
                reportClientDocument.getDatabaseController().getDatabase().getTables();
        final List<String> tableNames = new ArrayList<String>();
        for (final ITable table : tables) {
            tableNames.add(table.getAlias());
        }
        
        // Modify SQL: apply VPA restrictions
        sqlWithRestrictions =
                CrystalReportsAdaptorUtilities.applyRestrictions(tableNames, originalSqlStatement,
                    clientRestriction, applyVpa);
        
        return sqlWithRestrictions;
    }

    /**
     * Gets SQL statement from reportClientDocument.
     *
     * @param reportFileName is used to produce error message if ExceptionBase is thrown.
     * @param reportClientDocument Crystal Reports SDK document to be processed.
     * @return SQL generated by Crystal Reports SDK.
     * @throws ReportSDKException if Crystal Reports SDK throws an exception.
     */
    static String getSqlStatementFromReport(final String reportFileName,
            final ReportClientDocument reportClientDocument) throws ReportSDKException {
        // Get SQL from report
        // CrystalReports runtime will open here new database connection using database connection
        // parameters specified in the report
        final String originalSqlStatement =
                reportClientDocument.getRowsetController().getSQLStatement(new GroupPath(), null);

        if (originalSqlStatement.startsWith("No SQL Query has been used")) {
            final String errorMessage =
                    String
                    .format(
                        "Crystal Reports SDK returned message=[%s] , while generating SQL for report=[%s]",
                        originalSqlStatement, reportFileName);
            throw new ExceptionBase(errorMessage);
        }

        return originalSqlStatement;
    }

    /**
     * Replaces database connection parameters in reportClientDocument.
     * <p>
     * Gets connection parameters from context for "data" database.
     *
     * @param userAccount current user account.
     * @param reportClientDocument Crystal Reports SDK document to be processed.
     * @throws ReportSDKException if Crystal Reports SDK throws an exception.
     */
    static void replaceConnectionParameters(final UserAccount.Immutable userAccount,
            final ReportClientDocument reportClientDocument) throws ReportSDKException {
        // Get connection parameters from context for "data" database
        final ConfigJdbc.Immutable configJdbc =
                userAccount.findDatabase(DatabaseRole.DATA.toString()).getConfigJDBC();

        // Replace connection parameters
        CrystalReportsAdaptorUtilities.replaceConnectionParametersInAllTables(reportClientDocument,
            configJdbc);
    }

    /**
     * Applies VPA restrictions from current userAccount.
     *
     * @param tableNames list of table names in the sql.
     * @param sql SQL VPA to be applied to.
     * @param clientRestriction restriction passed from client-side.
     * @param applyVpa true if applying VPA restrictions and false otherwise.
     * @return SQL that has both SQL generated by Crystal Reports SDK and VPA restrictions.
     */
    static String applyRestrictions(final List<String> tableNames, final String sql,
            final String clientRestriction, final boolean applyVpa) {
        final DataSource dataSource = DataSourceFactory.createDataSource();

        for (final String tableName : tableNames) {
            dataSource.addTable(tableName.toLowerCase());
        }

        // Get the last order by Clause in the original query and save it.
        final int indexord = sql.toUpperCase().lastIndexOf("ORDER BY");
        String orderByClause = "";
        String newsql = "";

        if (indexord > 0) {
            orderByClause = sql.substring(indexord);
            // remove the last order by clause from the original query.
            newsql = sql.substring(0, indexord - 1);
        } else {
            newsql = sql;
            orderByClause = "";
        }
        // use the new query (no order by clause to append the VPA).
        dataSource.addQuery(newsql);
        
        dataSource.setApplyVpaRestrictions(applyVpa);
        
        dataSource.setContext(ContextStore.get().getEventHandlerContext());

        // append the order by to the end of the New formated with VPA query.
        return dataSource.formatSqlQuery(clientRestriction, false) + " " + orderByClause;

        // We had to do this work around because of the way the ARCHIBUS formatSqlQuery function
        // that add VPA restriction to the query by using the existing query as subquery
        // and do select * from (<QUERY>) <tableName> <VPARESTRICTION>)
        // which will cause issues if you have order by clauses inside.
        // another issue that we usually face with this method is if the existing query does not
        // have the vpa field in list of the column in the inner query i.e
        // ( select * from (select wr_id from wr ) wr where bl_id ='HQ') this will cause issues in
        // ARCHIBUS datasources.

    }

    /**
     * Replaces database connection parameters in all tables in reportClientDocument.
     * <p>
     * Extracts new database connection parameters from configJdbc.
     *
     * @param reportClientDocument Crystal Reports SDK document to be processed.
     * @param configJdbc with new database connection parameters.
     * @throws ReportSDKException if Crystal Reports SDK throws an exception.
     */
    static void replaceConnectionParametersInAllTables(
            final ReportClientDocument reportClientDocument, final ConfigJdbc.Immutable configJdbc)
                    throws ReportSDKException {
        final Tables tables =
                reportClientDocument.getDatabaseController().getDatabase().getTables();

        for (final ITable table : tables) {
            final ITable newTable =
                    replaceConnectionParameters(table, configJdbc.getJndiDataSourceName(),
                        configJdbc.getUrl(), configJdbc.getDriver(), configJdbc.getLogin(),
                        configJdbc.getPassword());

            // Update the table information
            reportClientDocument.getDatabaseController().setTableLocation(table, newTable);
        }
    }

    /**
     * Replaces database connection parameters in table.
     *
     * @param table in which database connection parameters will be replaced.
     * @param jndiName to be set in table.
     * @param connectionUrl to be set in table.
     * @param driverClassName to be set in table.
     * @param userName to be set in table.
     * @param password to be set in table.
     * @return table with new database connection parameters.
     */
    static ITable replaceConnectionParameters(final ITable table, final Object jndiName,
            final Object connectionUrl, final Object driverClassName, final String userName,
            final String password) {
        // Clone table
        final ITable newTable = (ITable) table.clone(true);
        newTable.setQualifiedName(table.getAlias());

        final IConnectionInfo connectionInfo = newTable.getConnectionInfo();

        final PropertyBag propertyBag = new PropertyBag();

        // Overwrite any existing properties with updated values
        propertyBag.put("Trusted_Connection", "false");
        propertyBag.put("Server Type", "JDBC (JNDI)");
        propertyBag.put("Use JDBC", "true");
        propertyBag.put("Database DLL", "crdb_jdbc.dll");
        propertyBag.put("JNDI Datasource Name", jndiName);
        propertyBag.put("Connection URL", connectionUrl);
        propertyBag.put("Database Class Name", driverClassName);

        connectionInfo.setAttributes(propertyBag);

        // Set database username and password
        connectionInfo.setUserName(userName);
        connectionInfo.setPassword(password);

        return newTable;
    }

    /**
     * Connects the report to the database. based on ICAD codes (03/2015).
     * 
     * @param clientDoc Crystal Reports SDK document to be processed.
     * @param username the current user log on name.
     * @param password the password for the current user.
     * @throws ReportSDKException if Crystal Reports SDK throws an exception.
     */
    public static void logonDataSource(final ReportClientDocument clientDoc, final String username,
            final String password) throws ReportSDKException {
        clientDoc.getDatabaseController().logon(username, password);
    }

    /**
     * Connects the report to the current "data" database.
     *
     * @param clientDoc Crystal Reports SDK document to be processed.
     * @param userAccount the current user that the database linked with.
     * @throws ReportSDKException if Crystal Reports SDK throws an exception.
     */
    static void logonDataSource(final ReportClientDocument clientDoc,
            final UserAccount.Immutable userAccount) throws ReportSDKException {
        // Get connection parameters from context for "data" database
        final ConfigJdbc.Immutable configJdbc =
                userAccount.findDatabase(DatabaseRole.DATA.toString()).getConfigJDBC();
        logonDataSource(clientDoc, configJdbc.getLogin(), configJdbc.getPassword());
    }
    
    /**
     * Changes the DataSource for a specific Table. Changes the Datasource for all tables if the
     * "tableName" parameter is null.
     *
     * @param clientDoc The reportClientDocument representing the report being used
     * @param reportName "" for main report, name of subreport for subreport, null for all reports
     * @param tableName name of table to change. null for all tables.
     * @param username The DB logon user name
     * @param password The DB logon password
     * @param propertyBag connection properties including connectionURL,driverName and JNDI name.
     * @throws ReportSDKException report SDK error.
     */
    public static void changeDataSource(final ReportClientDocument clientDoc,
            final String reportName, final String tableName, final String username,
            final String password, final PropertyBag propertyBag) throws ReportSDKException {

        // loop through all the main report and pass the connection information
        if (reportName == null || reportName.isEmpty()) {
            final Tables tables = clientDoc.getDatabaseController().getDatabase().getTables();
            setReportTableLocation(clientDoc, tableName, username, password, propertyBag, tables,
                    "");
        }

        // Next loop through all the subreports and pass in the same information.
        if (reportName == null || !(reportName.isEmpty())) {
            final IStrings subNames = clientDoc.getSubreportController().getSubreportNames();
            for (int subNum = 0; subNum < subNames.size(); subNum++) {
                final Tables tables =
                        clientDoc.getSubreportController().getSubreport(subNames.getString(subNum))
                        .getDatabaseController().getDatabase().getTables();
                setReportTableLocation(clientDoc, tableName, username, password, propertyBag,
                    tables, subNames.getString(subNum));
            }
        }
    }

    /**
     * Loops through all the tables and set the connection information.
     *
     * @param clientDoc The reportClientDocument representing the report being used
     * @param tableName name of table to change. null for all tables.
     * @param username The DB logon user name
     * @param password The DB logon password
     * @param propertyBag connection properties including connectionURL,driverName and JNDI name.
     * @param tables the tables to loop through and set.
     * @param subreportName the name of the subreport if any.
     *
     * @throws ReportSDKException report SDK error.
     */
    private static void setReportTableLocation(final ReportClientDocument clientDoc,
            final String tableName, final String username, final String password,
            final PropertyBag propertyBag, final Tables tables, final String subreportName)
                    throws ReportSDKException {
        IConnectionInfo connectionInfo;
        ITable origTable;
        ITable newTable;
        for (int i = 0; i < tables.size(); i++) {
            origTable = tables.getTable(i);
            if (tableName == null || origTable.getName().equals(tableName)) {
                newTable = (ITable) origTable.clone(true);

                newTable.setQualifiedName(origTable.getAlias());
                connectionInfo = newTable.getConnectionInfo();

                connectionInfo.getAttributes();

                // Overwrite any existing properties with updated values
                connectionInfo.setAttributes(propertyBag);

                connectionInfo.setUserName(username);
                connectionInfo.setPassword(password);

                // Update the table information
                if (StringUtil.notNullOrEmpty(subreportName)) {
                    clientDoc.getSubreportController().getSubreport(subreportName)
                    .getDatabaseController().setTableLocation(origTable, newTable);
                } else {
                    clientDoc.getDatabaseController().setTableLocation(origTable, newTable);
                }
            }
        }
    }

}
